<!doctype html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>新时代CSS布局</title>
    <meta name="description" content="CSS布局经常是令前段开发者头痛的一块工作。但是近几年来，浏览器不断提升，开始支持Flexbox，Grid，盒模型对齐等布局功能。这些CSS规范存粹是为了应付网络布局而编写的。在此会与大家分享这些新的CSS属性如何让我们创造更符合浏览器本质的设计。">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/jing.css">
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
    </script>
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <section data-background-image="img/background.jpg">
          <h1>新时代CSS布局</h1>
          <img data-src="img/qr-slides.png" class="plain" style="max-height:40vh" alt="幻灯片二维码">
          <p><small><a style="color:#a50104" href="https://www.chenhuijing.com/">陈慧晶</a> | <a style="color:#a50104" href="http://twitter.com/hj_chen">@hj_chen</a> | <svg height="1.5em" width="1.5em" viewBox="0 0 512 512"><g fill="#8bc34a"><path d="M512 320c0-70.688-71.648-128-160-128s-160 57.312-160 128 71.648 128 160 128c14.528 0 28.352-2.048 41.76-4.96L480 480l-29.824-59.616C487.552 396.96 512 360.928 512 320z"/><path d="M192 32C85.952 32 0 103.648 0 192c0 50.944 28.736 96.128 73.312 125.376L48 368l68.96-29.536c14.784 5.248 30.144 9.568 46.56 11.584-2.24-9.76-3.52-19.776-3.52-30.048 0-88.224 86.112-160 192-160 9.696 0 19.168.8 28.512 1.952C363.616 87.968 285.696 32 192 32z"/></g><g fill="#fafafa"><circle cx="128" cy="128" r="24"/><circle cx="256" cy="128" r="24"/><circle cx="304" cy="288" r="24"/><circle cx="400" cy="288" r="24"/></g></svg> jing74737871</small></p>
          <aside class="notes">大家好。很开心可以来到这里跟大家分享关于CSS布局的一些新进展。能够与那么多出色的CSS专家同台是我的荣幸。这是我第一次在中国演讲，也是第一次用中文演讲，所以如果有哪儿些用词不当的地方或者是一些词汇翻译的很古怪，要事先请大家多多包涵。</aside>
        </section>

        <section data-background-image="img/emoji-bg.png" data-background-repeat="repeat" data-background-size="200px">
          <div class="l-double" style="align-items:center">
            <div style="display:flex;flex-direction:column;align-items:center">
              <img data-src="img/name.svg" alt="Chen Hui Jing" class="plain" style="max-height:25vh">
              <div>
                <img data-src="img/avatar.jpg" alt="Jing" style="border-radius:50%;max-height:50vh">
              </div>
              <p>jing74737871</p>
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,3em);grid-template-rows:repeat(3,3em);width:100%;grid-template-areas:'a . b''. c .''d . e';font-size:150%">
              <span style="font-size:calc(1.75em + 3vw);grid-area:a" class="emoji" role="img" tabindex="0" aria-label="马来西亚">&#x1F1F2;&#x1F1FE;</span>
              <span style="font-size:calc(1.75em + 3vw);grid-area:b" class="emoji fragment" role="img" tabindex="0" aria-label="篮球">&#x1F3C0;</span>
              <span style="font-size:calc(1.75em + 3vw);grid-area:c" class="emoji fragment" role="img" tabindex="0" aria-label="女程序员">&#x1F469;&#x200D;&#x1F4BB;</span>
              <span style="font-size:calc(1.75em + 3vw);grid-area:d" class="emoji fragment" role="img" tabindex="0" aria-label="笔记">&#x1F4DD;</span>
              <span style="font-size:calc(1.75em + 3vw);grid-area:e" class="emoji fragment" role="img" tabindex="0" aria-label="狐狸">&#x1F98A;</span>
            </div>
          </div>
          <aside class="notes">
            <p>首先，让我来做个自我介绍。我姓陈，名叫慧晶，来自马来西亚。</p>
            <p>我曾经当过全职篮球选手，也因此无意间走上网络开发这条路。若你觉得很好奇，篮球怎么会跟网络开发扯上关系，那待会儿可以找我聊聊。</p>
            <p>从入行到现在，我一直都觉得CSS是一样相当有趣的东西，所以会经常探索新属性或更深入了解现有的属性，并且把学习经验写在博客上。</p>
            <p>去年也加入了谋智（Mozilla）技术讲师组，这项倡议主要是要协助技术布道和指导师在世界各地的技术会议推广开源网络科技。谋智会给予组员多方面的支持，如演讲培训、技术训练、资金等。</p>
          </aside>
        </section>

        <section>
          <img style="max-height:10em;margin-bottom:0.5em" class="plain" data-src="img/love-dev.svg" alt="Nexmo Developer Relations">
          <p><span class="emoji" role="img" tabindex="0" aria-label="avocado">&#x1F951;</span> 开发大使 <span class="emoji" role="img" tabindex="0" aria-label="avocado">&#x1F951;</span></p>
          <img style="max-height:2.5em;margin-top:1em" class="plain" data-src="img/nexmo.svg" alt="Nexmo">
          <aside class="notes">现在我在Nexmo担任开发大使，是开发者关系团队的成员之一。Nexmo是个通讯API平台，提供信息，语音，认证，音视频等API，好让开发者轻松把通信功能添加入自己的APP内。</aside>
        </section>

        <section data-background-image="img/cssconf2016.jpg">
          <aside class="notes">
            <p>那让我们进入正题吧，也就是新时代CSS布局。</p>
            <p>想请问在座的朋友们有几位参加过2016年的CSS大会？我当时…在家，没来。但是还好有视频，让我有机会在线观赏大漠老师谈CSS Grid Layout的演讲。也很高兴待会儿有机会在现场聆听他的演讲。</p>
            <p>他介绍了与Grid相关的各种新属性及它们的应用方法。Grid在那时候都还没正式发布呢。Grid可以算是新时代CSS布局的成员之一吧。</p>
          </aside>
        </section>

        <section>
          <div class="l-double">
            <h2 style="grid-column:span 2">为什么纵向比横向难排？</h2>
            <div>
              <div class="box" style="height:4em;width:6em;background-color:green;animation:horizontal 2s infinite"><span style="font-size:calc(1.75em + 3vw)" class="emoji" role="img" tabindex="0" aria-label="person gesturing ok">&#x1F646;</span></div>
            </div>
            <div>
              <div class="box" style="height:4em;width:6em;background-color:red;animation:vertical 2s infinite"><span style="font-size:calc(1.75em + 3vw)" class="emoji" role="img" tabindex="0" aria-label="person shrugging">&#x1F937;</span></div>
            </div>
          </div>
          <aside class="notes">不知道观众朋友们是否同意，但是我认为网络开发其中令人头痛的一点就是纵向的布局。经过一番研究，我才发现到原因是网络原本是个以文字为主的媒介。</aside>
        </section>

        <section data-background-image="img/wwwbrowser.png">
          <div style="display:flex;flex-direction:column;align-items:center">
            <p style="padding:0.5em;background:#2f313f;display:inline-block;border-radius:0.25em"><a href="https://worldwideweb.cern.ch/browser/">https://worldwideweb.cern.ch/browser/</a></p>
            <img data-src="img/qr-www.png" class="plain" style="max-height:40vh" alt="最原始WWW浏览器二维码">
          </div>
          <aside class="notes">
            <p>当年，蒂姆·伯纳斯-李爵士（Sir Tim Berners-Lee）创建万维网，主要是为了解决CERN面临的资讯管理问题。他提交了名为「信息管理：提案」这份文件，希望可以更轻易的管理和监控实验室研究流程。实验室文件不是用英文就是用法文写的。</p>
            <p>我也想顺便一提，为了纪念万维网诞生的30周年纪念，CERN召集了一群知名开发者，重建最原始的浏览器。有兴趣的朋友们可以到这个链接在线访问。</p>
          </aside>
        </section>

        <section data-background-image="img/browsers.jpg">
          <aside class="notes">早期的浏览器都注重西文文字的排版，重视的是从左到右的水平方向。初期的元素包括h1-6的标题元素、p元素、各式的列表元素。CSS在1996年发布时，多数的属性也是为了调整文字的布局而设。</aside>
        </section>

        <section>
            <img data-src="img/boxes.svg" style="max-height:25vmin"class="plain" alt="CSS新时代布局三大栋梁">
            <pre style="box-shadow:none;font-size:0.5em;text-align:center">
_______________________________________
|                                       |
|           margin (transparent)        |
|   _________________________________   |
|  |                                 |  |
|  |        border                   |  |
|  |   ___________________________   |  |
|  |  |                           |  |  |
|  |  |     padding               |  |  |
|  |  |   _____________________   |  |  |
|  |  |  |                     |  |  |  |
|  |  |  |  content            |  |  |  |
|  |  |  |_____________________|  |  |  |
|  |  |___________________________|  |  |
|  |_________________________________|  |
|_______________________________________|

|    element width    |

|               box width               |</pre>
          <aside class="notes">但是，CSS同时也介绍了以盒模型为主的布局方式。其实想一想，网络的所有内容，不都只是各式各类的盒子吗？虽然初期的属性有限，但是网络开发者非常有创意，利用浮动、负margin、各式的定位等技巧，来达成心仪的设计。</aside>
        </section>

        <section>
          <img data-src="img/new-layout.svg" class="plain" alt="CSS新时代布局三大栋梁">
          <aside class="notes">直到Flexbox的诞生。Flexbox可以算是有史以来第一个以网络本质为主而编写的CSS规范。连同Box Alignment跟CSS Grid，这三个项目可以称为CSS新时代布局的三大栋梁。</aside>
        </section>

        <section>
          <h2>CSS布局部队</h2>
          <img data-src="img/team-layout.png" class="plain" alt="CSS布局部队">
          <p>等属性…</p>
          <aside class="notes">当然，我们不能忘记CSS里头的其它553个属性。因为CSS是个团队项目。只有各属性相互协调配合，才能把CSS的威力完全发挥出来。</aside>
        </section>

        <section data-backgrond-transition="none">
          <div style="display:grid;grid-template-columns:40% 60%;justify-content:center">
            <img data-src="img/source.svg" alt="Source document" class="plain" style="max-height:65vh;justify-self:center">
            <img data-src="img/box-tree.svg" alt="Box tree" class="plain fragment" style="max-height:75vh">
          </div>
          <aside class="notes">如果要揭开CSS布局的神秘面纱，那就必须先熟悉浏览器的渲染过程。渲染引擎会把服务器发送过来的Source文档解析成浏览器能够明白的对象。而在渲染网页之前，浏览器会生成一个渲染树。这个渲染树是个中介性的结构（intermediary structure），是文档格式结构（formatting structure）的表示法。</aside>
        </section>

        <section data-backgrond-transition="none">
          <div style="display:grid;grid-template-columns:40% 60%;justify-content:center">
            <img data-src="img/source.svg" alt="Source document" class="plain" style="max-height:65vh;justify-self:center">
            <img data-src="img/box-tree-styles.svg" alt="Box tree" class="plain" style="max-height:75vh">
          </div>
          <aside class="notes">CSS在解析的过程，会计算出每个元素和文本节点的每个CSS属性值。浏览器就会靠其中的<code>display</code>取值来判断要生成哪一类的盒子。</aside>
        </section>

        <section>
          <h2><ruby><rb>CSS显示模块</rb><rt lang="en">CSS Display Module Level 3</ruby></h2>
          <div class="l-double" style="grid-gap:1em">
            <div>
              <h3><ruby><rb>内部显示类型</rb><rt lang="en">Inner display type</ruby></h3>
              <div class="fragment">
                <p>定义了元素内子元素的布局方式</p>
                <img data-src="img/inside-display.svg" alt="Inner display type" class="plain" style="max-height:30vh">
              </div>
            </div>
            <div>
              <h3><ruby><rb>外部显示类型</rb><rt lang="en">Outer display type</ruby></h3>
              <div class="fragment">
                <p>定义了元素怎样参与流式布局的处理</p>
                <img data-src="img/outside-display.svg" alt="Outer display type" class="plain" style="max-height:35vh">
              </div>
            </div>
          </div>
          <aside class="notes">
            <p>CSS显示模块在这二十多年来，经过不少演变。从一开始的基本<code>block</code>、<code>inline</code>和<code>list-item</code>到现在最新规范中一共有十七种属性值。可见，CSS是个不断在进展的技术，编辑组（CSS Working Group）也会聆听多方面的反馈来更新规范。</p>
            <p>Level 3的显示模块主要是为了更换及扩展在CSS2里<code>display</code>取值的定义。我在此描述的东西，很有可能还未在浏览器实现，但是我们可以从中事先理解未来CSS的行为。</p>
            <p>规范提出了两种显示类型，内部及外部。内部显示类型定义了元素内子元素的布局方式，外部显示类型则定义了元素怎样参与流式布局的处理。</p>
          </aside>
        </section>

        <section>
          <table style="font-size:75%">
            <thead>
              <tr style="border-bottom:3px solid black">
                <th width="20%"><ruby><rb>简写</rb><rt lang="en">Short <code>display</code></ruby></th>
                <th width="30%"><ruby><rb>全称</rb><rt lang="en">Full <code>display</code></ruby></th>
                <th><ruby><rb>生成盒子</rb><rt lang="en">Generated box</ruby></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>none</code></td>
                <td><code>—</code></td>
                <td>subtree omitted from box tree</td>
              </tr>
              <tr>
                <td><code>contents</code></td>
                <td><code>—</code></td>
                <td>element replaced by content in box tree</td>
              </tr>
              
              <tr>
                <td><code>table</code></td>
                <td><code>block table</code></td>
                <td>block-level table wrapper box containing table box</td>
              </tr>
              <tr>
                <td><code>inline-table</code></td>
                <td><code>inline table</code></td>
                <td>inline-level table wrapper box containing table box</td>
              </tr>
              <tr>
                <td><code>list-item</code></td>
                <td><code>block flow list-item</code></td>
                <td>block box with additional marker box</td>
              </tr>
              <tr>
                <td><code>inline list-item</code></td>
                <td><code>inline flow list-item</code></td>
                <td>inline box with additional marker box</td>
              </tr>
              <tr>
                <td><code>run-in</code></td>
                <td><code>run-in flow</code></td>
                <td>run-in box (inline box with special box-tree-munging rules) </td>
              </tr>
              <tr>
                <td><code>flex</code></td>
                <td><code>block flex</code></td>
                <td>block-level flex container</td>
              </tr>
              <tr>
                <td><code>inline-flex</code></td>
                <td><code>inline flex</code></td>
                <td>inline-level flex container</td>
              </tr>
            </tbody>
          </table>
          <aside class="notes">这个表是从规范直接引用的。它列出之前提到的十七个属性值，也描述这些取值会让浏览器生成什么样的盒子。Level 3规范详细说明了<code>display</code>属性的两类取值，可是到现在依然还没被浏览器广泛支持。即使被广泛支持后，单关键字还是可以继续用。</aside>
        </section>

        <section>
          <table style="font-size:75%">
            <thead>
              <tr style="border-bottom:3px solid black">
                <th width="20%"><ruby><rb>简写</rb><rt lang="en">Short <code>display</code></ruby></th>
                <th width="30%"><ruby><rb>全称</rb><rt lang="en">Full <code>display</code></ruby></th>
                <th><ruby><rb>生成盒子</rb><rt lang="en">Generated box</ruby></th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>ruby</code></td>
                <td><code>inline ruby</code></td>
                <td>inline-level ruby container</td>
              </tr>
              <tr>
                <td><code>block ruby</code></td>
                <td><code>block ruby</code></td>
                <td>block box containing ruby container</td>
              </tr>
              <tr>
                <td><code>grid</code></td>
                <td><code>block grid</code></td>
                <td>block-level grid container</td>
              </tr>
              <tr>
                <td><code>inline-grid</code></td>
                <td><code>inline-grid</code></td>
                <td>inline-level grid container</td>
              </tr>
              <tr>
                <td><code>block</code></td>
                <td><code>block flow</code></td>
                <td>block-level block container</td>
              </tr>
              <tr>
                <td><code>flow-root</code></td>
                <td><code>block flow-root</code></td>
                <td>block-level block container that establishes a new block formatting context (BFC)</td>
              </tr>
              <tr>
                <td><code>inline</code></td>
                <td><code>inline flow</code></td>
                <td>inline box</td>
              </tr>
              <tr>
                <td><code>inline-block</code></td>
                <td><code>inline flow-root</code></td>
                <td>inline-level block container</td>
              </tr>
            </tbody>
          </table>
          <aside class="notes">
            <p>各种属性值生成的盒子会创建不同的格式化上下文（formatting context）。打个比方，这个幻灯片上的词句翻译是用ruby标签来实现的。<code>display:ruby</code>会生成ruby容器盒子，而这种盒子建立的是ruby formatting context。</p>
            <p>相信大多数的人都有尝试过用Flexbox来布局。可能因为Flexbox的开发过程相当凌乱不堪，属性一而再再而三的修改，网络上Flexbox的教程有时会产生一些误解。最可靠的答案就藏在规范里头。</p>
          </aside>
        </section>

        <section>
          <h2>Flex简写及关键字</h2>
          <pre style="width:auto;display:inline-block;margin-bottom:1em"><code>[ <’flex-grow’> <’flex-shrink’>? || <’flex-basis’> ]   </code></pre>
          <table>
            <tr>
              <td style="width:14em"><code>flex: initial</code></td>
              <td><code>flex: 0 1 auto</code><br>不能生长，但是缺乏空间时可以缩小</td>
            </tr>
            <tr>
              <td><code>flex: auto</code></td>
              <td><code>flex: 1 1 auto</code><br>依照可用空间平均伸缩</td>
            </tr>
            <tr>
              <td><code>flex: none</code></td>
              <td><code>flex: 0 0 auto</code><br>完全不伸缩，简直是僵化</td>
            </tr>
            <tr>
              <td><code>flex: &lt;positive-number&gt;</code></td>
              <td><code>flex: &lt;positive-number&gt; 1 0</code><br>能屈能伸，属性值断定生长的比例</td>
            </tr>
          </table>
          <aside class="notes">
            <p>规范编辑强调利用简写的<code>flex</code>属性，因为它会正确的重置相关的属性值。而<code>flex</code>简写有几个关键字，是为了应付最常见的用例而设的。</p>
            <p>当你把<code>display:flex</code>设在一个元素上时，即使你不在子元素设定任何<code>flex</code>取值，浏览器自己会套上<code>flex:initial</code>这个默认值，计算出来变成<code>0 1 auto</code>。</p>
            <p>如果你想要子元素伸缩自如，那可以设一个<code>flex:auto</code>的取值，让子元素随着容器的空间同一频率伸缩。</p>
            <p>若你的理想设计内有几个flex项目是必须有固定的尺寸，可以用<code>flex:none</code>让它失去弹性功能，永远都保持自己的尺寸。最后，如果你用单单一个正整数为取值，浏览器就会把这个整数设为<code>flex-grow</code>的取值，而与其的两个取值会重置为<code>1</code>和<code>0</code>。</p>
          </aside>
        </section>

        <section>
          <h2>自动margin是你的好友</h2>
          <div class="livecode livecode-2p">
            <div class="result automargin" style="font-size:75%">
              <div>
                <img class="plain" data-src="img/nexbox.svg" style="width:4em">
              </div>
            </div>
            <div class="code"><style class="code-editor" contenteditable="true">.automargin {
  display: flex;
}

.automargin div {
  
}</style></div>
          </div>
          <aside class="notes">
            <p>话也讲多了，大家应该也闷了。来些show me the code，会有趣一点吧。首先，来个小基本：自动margin。Flex容器内的子元素被浏览器视为flex项目，CSS布局最关键的转折点就在于这个父子关系。</p>
            <p>在这个简单的例子，容器内只有一个子元素。我们可以运用margin来操纵它。</p>
            <p>如果不设定任何方向，盒子就会在容器的正中间。一行搞定水平垂直居中的问题。</p>
          </aside>
        </section>

        <section>
          <h2>自动margin是你的好友</h2>
          <div class="livecode livecode-2p">
            <div class="result navbar" style="font-size:75%;display:flex;flex-direction:column;justify-content:center">
              <ul style="list-style:none;margin:0;background-color:#2f313f;padding:1em 0">
                <li><a style="padding:1em" href="javascript:void(0)">首页</a></li>
                <li><a style="padding:1em" href="javascript:void(0)">动态</a></li>
                <li><a style="padding:1em" href="javascript:void(0)">话题</a></li>
                <li><a style="padding:1em" href="javascript:void(0)">活动</a></li>
                <li><a style="padding:1em" href="javascript:void(0)">登录 · 注册</a></li>
              </ul>
            </div>
            <div class="code"><style class="code-editor" contenteditable="true">.navbar ul {
  display: flex;
}

.navbar li:last-child {
  
}</style></div>
          </div>
          <aside class="notes">
            <p>一个比较实际的用例则是网页的页眉。页眉经常会有类似这种设计模式。导航栏的几个链接都偏向左边，然后登录注册的链接独自在右边。我们只需要在页眉设一个<code>display:flex</code>，再用自动margin把最后一个列表项推到右边尾端去就好了。比之前的实现方法方便多了。</p>
          </aside>
        </section>

        <section>
          <h2>为什么块格式自动margin不垂直居中元素？</h2>
          <blockquote>
            <p>If both margin-left and margin-right are auto, their used values are equal, causing horizontal centring.</p>
            <br><small>—CSS2 Visual formatting model details: 10.3.3</small>
          </blockquote>
          <blockquote>
            <p>If <code>margin-top</code>, or <code>margin-bottom</code> are <code>auto</code>, their used value is <code>0</code>.</p>
            <br><small>—CSS2 Visual formatting model details: 10.6.3</small>
          </blockquote>
          <aside class="notes">
            <p>在学习CSS布局时，这个问题我想了很久。最后仔细翻阅规范后才明白，如果元素的高度设为<code>auto</code>，那浏览器在计算它的高度时，只会考虑元素内容及子元素，纵向没有已确定的空间来调整位置。</p>
            <p>即使元素设了固定的高度，别忘记它跟子元素是互不相关的。这很有可能是浏览器最初执行的抉择遗留下来的行为。浏览器没办法计算上下方的margin取值，所以就把<code>auto</code>取值解析成<code>0</code>。</p>
          </aside>
        </section>

        <section>
          <h2>容器–项目的「父子」关系</h2>
          <img data-src="img/parent-child.svg" class="plain" alt="容器–项目图">
          <aside class="notes">我之前提到的转折点就在这儿。因为flex或grid容器跟子元素的关系，在布局时是被浏览器承认的。因此，浏览器才有办法计算出四面的自动margin取值。</aside>
        </section>

        <section>
          <h2><ruby><rb>CSS盒式对齐模块</rb><rt lang="en">CSS Box Alignment Level 3</ruby></h2>
          <div class="l-double">
            <div>
              <h3>Flexbox</h3>
              <img class="plain" style="height:3.5em;display:block;margin:0 auto 0.5em" data-src="img/flexbox.svg" alt="Flexbox">
              <ul>
                <li><code>align-content</code></li>
                <li><code>justify-content</code></li>
                <li><code>align-items</code></li>
                <li><code>align-self</code></li>
              </ul>
              <p><code>justify-items</code>/<code>justify-self</code> 在flex项目是<strong>用不上</strong>的。</p>
            </div>
            <div>
              <h3>Grid</h3>
              <img class="plain" style="height:3.5em;display:block;margin:0 auto 0.5em" data-src="img/grid.svg" alt="Grid">
              <ul>
                <li><code>align-content</code></li>
                <li><code>justify-content</code></li>
                <li><code>align-items</code></li>
                <li><code>align-self</code></li>
                <li><code>justify-items</code></li>
                <li><code>justify-self</code></li>
              </ul>
            </div>
          </div>
          <aside class="notes">
            <p>当然，光靠自动margin是不够的。要更精确的调整子元素的位置，我们可以运用盒式对齐模块（box alignment）提供的属性值。Flexbox的首个公开工作草案是在2009发布的，而Grid的则是2011发布。</p>
            <p>当时两个规范设定了两组不同的对齐属性。经过讨论，工作组决定把盒子对齐写成独立的规范，让过去、现在和未来的formatting contexts都统一使用相同的属性。</p>
            <p>Box alignment的属性一共有六个。在使用flex时，用得上其中四个，使用grid的话，六个属性全部都能用。</p>
          </aside>
        </section>

        <section>
          <img class="plain" style="height:2.5em;position:fixed;top:0;right:0" data-src="img/grid.svg" alt="Grid">
          <h2><code>justify-content</code> 和 <code>align-content</code></h2>
          <div class="livecode livecode-2p" style="grid-template-columns:60% calc(40% - 0.5em)">
            <div class="result gridcontent">
              <div class="box a">A</div>
              <div class="box b">B</div>
              <div class="box c">C</div>
              <div class="box d">D</div>
            </div>
            <div class="code"><style class="code-editor" contenteditable="true">.gridcontent {
  justify-content: normal;
  align-content: normal;

  display: grid;
  grid-template-columns: repeat(3, 25%);
  grid-template-rows: repeat(3, 20%);
  grid-gap: 1em;
  grid-template-areas: 
    "a b b"
    "a b b"
    "c c d";
}

.gridcontent .box.a { grid-area: a }
.gridcontent .box.b { grid-area: b }
.gridcontent .box.c { grid-area: c }
.gridcontent .box.d { grid-area: d }</style></div>
          </div>
          <aside class="notes">
            <p><code>justify-content</code>及<code>align-content</code>属性被视为内容分配属性（content-distribution properties），当容器内有多余的空间时才会生效。</p>
            <p>在这个grid的例子，你们可以看到grid项目的右边和下面都有些多余的空间。因此我们可以运用<code>justify-content</code>及<code>align-content</code>来对齐这些子元素。</p>
            <p>调整整个网格的行列可以用<code>start</code>、<code>center</code>和<code>end</code>这三个取值。调整行列之间的空间则可以使用<code>space-around</code>、<code>space-between</code>和<code>space-evenly</code>。</p>
          </aside>
        </section>

        <section height="100vh">
          <img class="plain" style="height:2.5em;position:fixed;top:0;right:0" data-src="img/flexbox.svg" alt="Flexbox">
          <h2><code>justify-content</code> 和 <code>align-content</code></h2>
          <div class="livecode livecode-2p">
            <div class="result flexcontent">
              <div class="wrapper" style="font-size:70%">
                <div class="box">1一</div>
                <div class="box">2二</div>
                <div class="box">3三</div>
                <div class="box">4四</div>
                <div class="box">5五</div>
                <div class="box">6六</div>
                <div class="box">7七</div>
                <div class="box">8八</div>
                <div class="box">9九</div>
                <div class="box">10十</div>
                <div class="box">11十一</div>
                <div class="box">12十二</div>
                <div class="box">13十三</div>
                <div class="box">14十四</div>
                <div class="box">15十五</div>
                <div class="box">16十六</div>
                <div class="box">17十七</div>
                <div class="box">18十八</div>
                <div class="box">19十四</div>
                <div class="box">20二十</div>
              </div>
            </div>
            <div class="code"><style class="code-editor" contenteditable="true">.flexcontent .wrapper {
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  align-content: stretch;
  height: 70vh;
}

.flexcontent .box {
  height: 3.5em;
  width: 4.5em;
  border: 1px solid;
}</style></div>
          </div>
          <aside class="notes">
            <p>用在flexbox时，<code>justify-content</code>定义了项目在主轴（main axis）上的对齐方式。项目的尺寸及自动margin调配好之后，剩下来的空间可以用<code>justify-content</code>来分配。如果注意看这个例子，你会注意到右边有些剩余的空间。</p>
            <p>默认值是<code>flex-start</code>。我们可以用<code>flex-end</code>或<code>center</code>移动整组flex项目。而flex项目之间的空间则可以用<code>space-around</code>, <code>space-between</code>和<code>space-evenly</code>来调整。</p>
            <p>由于项目很多，这个容器出现了多根轴线（multiple flex lines）的现象。在这种状况下，<code>align-content</code>就可以派上用场。因为它是多根轴线的对齐方式。如果轴线只有一条，这个属性是没有效果的。<code>align-content</code>的默认值是<code>stretch</code>，所以当轴线只有一条时，这个单轴线就会伸长，占满整个flex line的空间。</p>
            <p>我们可以用之前提到的六个取值来对齐轴线，或则分配轴线之间的空间。</p>
          </aside>
        </section>

        <section>
          <img class="plain" data-src="img/axis-alignment.svg" alt="*-content values">
          <aside class="notes">之前在画插图时，有点走火入魔的现象，越画越过瘾。待会儿你们还会看到很多盒子的插图。这个是用来表示<code>justify-content</code>及<code>align-content</code>各个属性值的效果。</aside>
        </section>

        <section>
          <img class="plain" style="height:2.5em;position:fixed;top:0;right:0" data-src="img/grid.svg" alt="Grid">
          <h2><code>justify-self</code> 和 <code>align-self</code></h2>
          <div class="livecode livecode-2p">
            <div class="result gridself">
              <div style="border:1px solid" class="box a">A</div>
              <div style="border:1px solid" class="box b">B</div>
              <div style="border:1px solid" class="box c">C</div>
              <div style="border:1px solid" class="box d">D</div>
            </div>
            <div class="code"><style class="code-editor" contenteditable="true">.gridself .box.a {
  grid-area: a;
  padding-top: 0.5em;
  align-self: ;
}

.gridself .box.b {
  grid-area: b;
  padding: 1em;
  align-self: start;
  //justify-self: start;
}

.gridself .box.c {
  grid-area: c;
  align-self: end;
  //justify-self: end;
}

.gridself .box.d {
  grid-area: d;
  align-self: center;
  //justify-self: center;
}

.gridself {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-gap: 1em;
  grid-auto-rows: calc(25% - 1em);
  grid-template-areas: 
    "a a b b"
    "a a b b"
    "c c d d"
    "c c d d";
}</style></div>
          </div>
          <aside class="notes">
            <p>Grid项目可以用<code>justify-self</code>和<code>align-self</code>来对齐自己。它们则被归类成自我对齐属性（self-alignment properties），允许我们操控项目在网格区域的位置。两轴的默认值都是<code>stretch</code>。表示项目在默认情况下，都会占据网格区域的整个空间。</p>
            <p>调整位置时可以用<code>start</code>、<code>center</code>、<code>end</code>或者<code>baseline</code>，这几个取值。要注意的一点是当我们用上<code>stretch</code>以外的取值后，项目就会缩到内容的尺寸。</p>
          </aside>
        </section>

        <section>
          <img class="plain" style="height:2.5em;position:fixed;top:0;right:0" data-src="img/grid.svg" alt="Grid">
          <h2><code>justify-items</code> 和 <code>align-items</code></h2>
          <div class="livecode livecode-2p">
            <div class="result griditems" style="font-size:75%">
              <div style="border:1px solid" class="box a">A</div>
              <div style="border:1px solid" class="box b">B</div>
              <div style="border:1px solid" class="box c">C</div>
              <div style="border:1px solid" class="box d">D</div>
            </div>
            <div class="code"><style class="code-editor" contenteditable="true">.griditems {
  justify-items: legacy;
  align-items: normal;

  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-gap: 1em;
  grid-auto-rows: calc(25% - 1em);
  grid-template-areas: 
    "a a b b"
    "a a b b"
    "c c d d"
    "c c d d";
}

.griditems .box.a { grid-area: a }
.griditems .box.b { grid-area: b }
.griditems .box.c { grid-area: c }
.griditems .box.d { grid-area: d }</style></div>
          </div>
          <aside class="notes"><code>align-items</code>和<code>justify-items</code>这两个属性可以用来设定容器内所有项目的默认<code>align-self</code>和<code>justify-self</code>的行为。</aside>
        </section>

        <section>
          <img class="plain" style="height:2.5em;position:fixed;top:0;right:0" data-src="img/flexbox.svg" alt="Flexbox">
          <h2><code>align-items</code> 和 <code>align-self</code></h2>
          <div class="livecode livecode-2p">
            <div class="result flexitems">
              <div class="wrapper" style="font-size:50%">
                <div class="box">1一</div>
                <div class="box">2二</div>
                <div class="box">3三</div>
                <div class="box">4四</div>
                <div class="box">5五</div>
                <div class="box">6六</div>
                <div class="box">7七</div>
                <div class="box">8八</div>
                <div class="box">9九</div>
                <div class="box">10十</div>
                <div class="box">11十一</div>
                <div class="box">12十二</div>
                <div class="box">13十三</div>
                <div class="box">14十四</div>
                <div class="box">15十五</div>
                <div class="box">16十六</div>
                <div class="box">17十七</div>
                <div class="box">18十八</div>
                <div class="box">19十四</div>
                <div class="box">20二十</div>
              </div>
            </div>
            <div class="code"><style class="code-editor" contenteditable="true">.flexitems .wrapper {
  display: flex;
  flex-wrap: wrap;
  align-items: stretch;
}

.flexitems .box:nth-child(2n+1) { 
  padding: 0.5em 1.5em 3em;
  align-self: ;
} 

.flexitems .box { border: 1px solid }
.flexitems .box:nth-child(2n) { padding: 2.5em; } 
.flexitems .box:nth-child(3n) { padding: 1.5em; }
.flexitems .box:nth-child(3n+2) { padding: 3.5em 1em; }</style></div>
          </div>
          <aside class="notes">
            <p>用在flexbox时，<code>align-items</code>和<code>align-self</code>指定了项目在交叉轴（cross-axis）上如何对齐。它们的默认值与grid相同，也是<code>stretch</code>。我们可以用<code>start</code>、<code>center</code>和<code>end</code>来调整所有项目在交叉轴上的位置。</p>
            <p><code>baseline</code>这个取值可能比较少见，但是如果你的项目尺寸不一致，导致文本上下不齐，那么就可以利用<code>baseline</code>把文本对齐。</p>
            <p>如果只是想调整其中几个项目的位置，那就用<code>align-self</code>，可以让个别项目有自己的位置。</p>
          </aside>
        </section>

        <section>
          <img class="plain" data-src="img/cross-alignment.svg" alt="*-items/self values">
          <aside class="notes">又来一些盒子插图，最后这个baseline取值比较难用插图来呈现，只好这样子啦。没办法，我的创意有限。</aside>
        </section>

        <section>
          <h2>Grid或者Flexbox?</h2>
          <h2 class="fragment j-stamp">问错了!</h2>
          <aside class="notes">有些人会问我，Flexbox和Grid要选谁比较好？我都会回答说，你这问题问错了。因为这不是个二选一的状况，应该是二合一才对。</aside>
        </section>

        <section>
          <h2>Flexbox（单维）</h2>
          <img class="plain" data-src="img/flex-1d.svg" alt="Flexbox的假冒行列">
          <aside class="notes">Flexbox比较适合单维方向的布局。因为运用Flexbox来实现的行列，即使对齐了，也只是个假象。Flexbox的行跟列是互不相关的。但是在单维布局，它拥有最强的弹性功能。</aside>
        </section>

        <section>
          <h2>Grid（二维）</h2>
          <img class="plain" data-src="img/grid-2d.svg" alt="Grid的真实行列">
          <aside class="notes">Grid则适合做二维网格布局，因为Grid中的行列才是真实的，才是是有关系的。你可以像在棋盘上排棋子似的，把Grid项目排成理想的布局。</aside>
        </section>

        <section>
          <h2>Grid和Flex合作愉快</h2>
          <div class="l-double" style="justify-items:center">
            <img class="plain" data-src="img/moholy.jpg" alt="Page 126 of Malerei, Fotografie, Film by Moholy-Nagy" style="max-height:75vh"> 
            <img class="plain fragment" data-src="img/moholy2.jpg" alt="Recreation of page 126 of Malerei, Fotografie, Film with grid and flexbox" style="max-height:75vh">
          </div>
          <aside class="notes">要实现类似这样的设计，用新时代布局方式是做得到的。要如何实现这种内容不对齐，环绕每个Grid单元厚厚的border？如果单靠Grid，用Box alignment属性，可以吗？</aside>
        </section>

        <section>
          <div class="l-double" style="justify-items:stretch">
            <figure>
              <img class="plain" style="height:8em" data-src="img/fit.svg" alt="Self-alignment properties">
              <figcaption>实现失败</figcaption>
            </figure>
            <figure class="fragment">
              <img class="plain" style="height:8em" data-src="img/flex.svg" alt="Display flex on grid items">
              <figcaption>这样还差不多</figcaption>
            </figure>
          </div>
          <aside class="notes">
            <p>很可惜，做不到。之前有提过，Grid项目对齐的默认值是<code>stretch</code>。一旦用上任何<code>stretch</code>以外的取值时，项目就会马上缩到内容的尺寸。</p>
            <p>可是如果我们在Grid项目上设一个<code>display:flex</code>，把它变成Flex容器。那表示Grid项目里面的内容，成为了Flex项目。现在利用Box alignment的各属性调整内容的位置就不会影响到Grid项目的尺寸，border也可以保持在Grid线上了。</p>
          </aside>
        </section>

        <section>
          <h2>百分比的局限</h2>
          <p>一致性的伸缩率</p>
          <video autoplay loop>
            <source data-src="videos/percentage.mp4" type="video/mp4">
            Sorry, your browser doesn't support embedded videos, 
            but don't worry, you can <a href="videos/percentage.mp4">download it</a>
            and watch it with your favourite video player!
          </video>
          <aside class="notes">
            <p>现在已经相当普遍的响应式网页设计，主要是依靠百分比来设定元素的尺寸。运用百分比的局限就是每个元素伸缩率是一致的。有时，这会导致开发者为了应付各种viewport尺寸范围，被逼要写数不清的media query。</p>
            <p>就拿这只小猫当例子，当viewport偏大时，图案就太大，当viewport偏小时，图案又太小。因为图案是拥有屏幕比例（aspect ratio）的元素，跟文本的行级流式显然不同。但是没办法，因为百分比始终是依赖容器尺寸来计算的。</p>
          </aside>
        </section>

        <section>
          <h2><ruby><rb>以内容为主的尺寸计算方式</rb><rt lang="en">（content-based sizing）</rt></ruby></h2>
          <div class="l-double" style="grid-gap:1em">
            <div>
              <h3><ruby><rb>外部尺寸</rb><rt lang="en">Extrinsic sizing</ruby></h3>
              <p>以元素的上下文为主，忽视元素内容</p>
              <div style="width:700px;height:300px;border:2px dashed #a50104">这是个含有内容的块格式盒子。我们可以利用它来理解extrinsic sizing的原理。我们把它的宽度设为700px，把高度设为300px。当内容超出可用空间时，就会导致内容溢流的现象。</div>
            </div>
            <div>
              <h3><ruby><rb>内部尺寸</rb><rt lang="en">Intrinsic sizing</ruby></h3>
              <p>以元素的内容为主，忽视元素上下文</p>
              <div style="width:min-content;border:2px dashed #a50104">用<code>min-content</code>为<code>width</code>取值</div>
              <div style="width:max-content;border:2px dashed #a50104">用<code>max-content</code>为<code>width</code>取值</div>
            </div>
          </div>
          <aside class="notes">
            <p>我们最常见的做法就是设定元素的宽度或高度，通常只设其中一个属性的取值，让浏览器自动调整另一个取值。而当我们固定两个范围的取值时，内容有可能会溢流到容器之外。</p>
            <p>其实内部尺寸不算新奇，只是我们通常不会去注意自己在用它。CSS其中以个较新的规范，CSS Intrinsic & Extrinsic Sizing Module Level 3，介绍了以内容为主的尺寸属性值，<code>min-content</code>和<code>max-content</code>。</p>
            <p>两年前参与了中文布局任务团之后才发现数字化排版的种种挑战。中文和西文的处理方式迥然不同。例如纵横对齐、比例字体、标点符号的挤压等等，在西文是不存在的。当然西文也有自己需要应付的问题。西文单词基本上是不分隔为两行的。</p>
          </aside>
        </section>

        <section>
          <img class="plain" style="max-height:100vh" data-src="img/min-content.png" alt="中西文min-content的偏差">
          <aside class="notes">这例子的八个字的宽度都被设为<code>min-content</code>。在西文用<code>min-content</code>时，只要没有空格、短横线、或特别的设置，最小宽度一般会依照连续的英文字符单元来决定。汉字的最小宽度则是一个汉字的宽度，通常就是<code>1em</code>。</aside>
        </section>

        <section>
          <h2>独特的<ruby><rb>灵活性尺寸</rb><rt lang="en">（flexible sizing）</rt></ruby></h2>
          <ul>
            <li>fr</li>
            <li>auto</li>
            <li>minmax()</li>
            <li>fit-content()</li>
          </ul>
          <p><code>fit-content(400px)</code>等于<code>minmax(auto, max-content)</code>，但是终宽度不能超出<code>400px</code>。</p>
          <aside class="notes">在深入研究这些新的布局模式时，我发现到最有趣的东西是灵活性尺寸。根据所设定的属性值，元素伸缩的变化率是有差别的。有些属性值会「坚持自己的立场」，在viewport变化的状况下，尽量保持范围内的宽度。这样讲有点难了解，还是看看一些用例吧。</aside>
        </section>

        <section>
          <h2><code>fr</code>对比<code>auto</code></h2>
          <p><span style="background-color:limegreen">绿色：<code>fr</code></span>，<span style="background-color:skyblue">蓝色：<code>auto</code></span></p>
          <video loop controls>
            <source data-src="videos/fr-auto.mp4" type="video/mp4">
            Sorry, your browser doesn't support embedded videos, 
            but don't worry, you can <a href="videos/fr-auto.mp4">download it</a>
            and watch it with your favourite video player!
          </video>
          <aside class="notes">
            <p>接下来的这些例子都会用grid来实现。所以这些有灵活性的属性值都设在<code>grid-template-columns</code>上。我们先来对比<code>fr</code>跟<code>auto</code>用在一起时会有什么效果。绿色是<code>fr</code>，蓝色是<code>auto</code>。</p>
            <p><code>fr</code>是多余空间（free space）的数量单位。所以有多余的空间时，浏览器会把空间都分配给<code>fr</code>值的那一栏。<code>fr</code>也可以用来规定多余空间分配的比例。</p>
            <p>第一行的分配比例是1对2对1。因为每个栏都用<code>fr</code>，无论viewport怎么变，只要有多余空间，中间栏的宽度永远都是旁边两个的一倍。</p>
            <p>当然，空间不足时，浏览器也会第一时间把空间取回。viewport变小时，绿色栏的内容最先分隔，缩到<code>min-content</code>值后，蓝色<code>auto</code>栏里的内容才开始分隔。</p>
          </aside>
        </section>

        <section>
          <h2><code>max-content</code>对比固定<code>width</code></h2>
          <p><span style="background-color:silver">灰色：<code>max-content</code></span>，<span style="background-color:violet">粉红色：<code>400px</code></span></p>
          <video loop controls>
            <source data-src="videos/fixed-max.mp4" type="video/mp4">
            Sorry, your browser doesn't support embedded videos, 
            but don't worry, you can <a href="videos/fixed-max.mp4">download it</a>
            and watch it with your favourite video player!
          </video>
          <aside class="notes">其实这个例子没什么特别的，因为max-content本身就是个固定取值。有固定取值的存在时，有灵活性的栏就会承担空间调整的责任。</aside>
        </section>

        <section>
          <h2><code>fit-content</code>对比<code>minmax()</code></h2>
          <p><span style="background-color:coral">橙色：<code>fit-content(200px)</code></span>，<span style="background-color:gold">黄色：<code>minmax(200px, 400px)</code></span></p>
          <video loop controls>
            <source data-src="videos/minmax-fit.mp4" type="video/mp4">
            Sorry, your browser doesn't support embedded videos, 
            but don't worry, you can <a href="videos/minmax-fit.mp4">download it</a>
            and watch it with your favourite video player!
          </video>
          <aside class="notes">
            <p>这个例子就有趣多了。橙色是<code>fit-content(200px)</code>，黄色是<code>minmax(200px, 400px)</code>。这两个取值的行为是类似的。被传入<code>minmax()</code>函数的第一个参数是尺寸下限，而第二个参数是尺寸上限。</p>
            <p><code>fitcontent()</code>函数也可以当<code>minmax()</code>函数来看待，只是它的尺寸下限是<code>min-content</code>，而尺寸上限是<code>max-content</code>和引数值当中较小的取值。</p>
            <p>因此，viewport在缩小时，<code>auto</code>和<code>fitcontent()</code>的行为和量变率是相同的。viewport变大时，<code>fitcontent()</code>被引数值约束了，长到<code>200px</code>就不能再长了。<code>auto</code>和<code>minmax()</code>会继续伸长，可是<code>auto</code>到了<code>max-content</code>的宽度时，会停下来，让<code>minmax()</code>长到尺寸上限后，才继续伸长下去。</p>
          </aside>
        </section>

        <section>
          <video loop autoplay>
            <source data-src="videos/florence.mp4" type="video/mp4">
            Sorry, your browser doesn't support embedded videos, 
            but don't worry, you can <a href="videos/florence.mp4">download it</a>
            and watch it with your favourite video player!
          </video>
          <aside class="notes">这两个网页有些微妙的偏差，在viewport偏大及偏小的状况下才会明显。重点是，有了这些新属性值，网络上的编辑设计可以更有艺术指导。Grid的网路线定位允许开发者轻松的实现重叠式的设计。再加上grid轨道灵活的伸缩功能，让我们在实现响应性设计时，有更多富有创意的选择。</aside>
        </section>

        <section>
          <h2>支持旧款浏览器</h2>
          <p>利用<code>@supports</code>，本地CSS功能检测</p>
          <pre style="font-size:100%"><code>.selector {
  /* Styles that are supported in old browsers */
}

@supports (property:value) {
  .selector {
    /* Styles for browsers that support the specified property */
  }
}</code></pre>
          <aside class="notes">
            <p>Grid正式发布到现在，已经有大概两年的时间，浏览器的支持程度如今也高达88%，可以算是被广泛支持了。但是其它12%的用户该怎么办呢？其实CSS可以通过feature query做功能检测。它的语法类似media query，只是用的关键字是<code>@supports</code>。</p>
            <p>我虽然提到grid当例子，但是feature queries可以用在任何一个CSS属性。<code>@supports</code>的支持率高达94%。浏览器不支持它也没关系，因为不认得<code>@supports</code>的浏览器就会忽视整个声明块内的CSS声明。</p>
            <p>建议把回退样式写在前头，接下来的新属性包含在<code>@supports</code>规则内。运用这种渐进增强的实现方法好处就在于连运用旧款浏览器的用户，都可以顺利的浏览你的网页。</p>
          </aside>
        </section>

        <section>
          <video loop autoplay>
            <source data-src="videos/supports.mp4" type="video/mp4">
            Sorry, your browser doesn't support embedded videos, 
            but don't worry, you can <a href="videos/supports.mp4">download it</a>
            and watch it with your favourite video player!
          </video>
          <aside class="notes">
            <p>在这里可以看到用feature queries实现的布局。左上角的浏览器是IE11。由于它不支持<code>@supports</code>，grid布局的声明块完全不影响它。IE11的用户依然可以浏览网页的内容，从中受益。用较新款浏览器的用户则可以享受被提升的布局和功能。</p>
            <p>时间也差不多了。在结束之前我只想说，即使我刚才所说的一切你都不记得，我要求你们牢牢记住这个问题的答案。</p>
          </aside>
        </section>

        <section data-background-video="videos/no.mp4" data-background-video-muted>
          <aside class="notes">网站需要在每个浏览器都长得一摸一样吗？No。</aside>
        </section>

        <section>
          <h2>致谢</h2>
          <p>谢谢CSS女神/攀岩高手，皋玮，做我的编辑。</p>
          <img class="plain" style="max-height:75vh" data-src="img/wei.jpg" alt="CSS女神，皋玮">
          <aside class="notes">最后，我也要感谢一位跟我一样热爱CSS的好友，皋玮，帮我修正错字连篇的演讲稿。</aside>
        </section>

        <section>
          <h2>参考链接</h2>
          <ul>
            <li><a href="https://worldwideweb.cern.ch/browser/">WorldWideWeb 浏览器</a></li>
            <li><a href="https://arstechnica.com/information-technology/2011/10/before-netscape-forgotten-web-browsers-of-the-early-1990s/">Before Netscape: the forgotten Web browsers of the early 1990s</a></li>
            <li><a href="https://www.w3.org/TR/REC-CSS1-961217">Cascading Style Sheets, level 1 (W3C 推荐标准 17 Dec 1996)</a></li>
            <li><a href="https://www.w3.org/Style/CSS/all-properties.en.html">CSS属性列表</a></li>
            <li><a href="https://www.w3.org/TR/css-display-3/">CSS显示模块 Level 3</a></li>
            <li><a href="https://www.w3.org/TR/css-flexbox-1/">CSS弹性盒式布局模块 Level 1</a></li>
            <li><a href="https://www.w3.org/TR/CSS2/visudet.html">CSS2.1: 10 视觉格式化模型细节</a></li>
            <li><a href="https://www.w3.org/TR/css-align-3/">CSS盒式对齐模块 Level 3</a></li>
            <li><a href="https://www.w3.org/TR/css-sizing-3/">CSS Intrinsic & Extrinsic Sizing Module Level 3</a></li>
            <li><a href="https://24ways.org/2017/cascading-web-design/">Cascading Web Design with Feature Queries</a></li>
            <li><a href="https://www.chenhuijing.com/demos/green-tea1/">渐进增强布局</a></li>
          </ul>
          <aside class="notes">这里有些参考链接，过后会跟大家分享。希望通过这个演讲可以让在座的朋友们有所启发。运用这些新属性去尝试实现通用型的网络设计，创造更符合浏览器本质的网页。</aside>
        </section>
        
        <section style="text-align:left">
          <h1>谢谢!</h1>
          <p><img class="j-icon plain" data-src="img/home.png" alt="Website"><a href="https://www.chenhuijing.com" style="display:inline-block;vertical-align:middle">https://www.chenhuijing.com</a></p>
          <p><img class="j-icon plain" data-src="img/wechat.png" alt="Wechat"><span style="display:inline-block;vertical-align:middle">jing74737871</span></p>
          <p><img class="j-icon plain" data-src="img/yuque.png" alt="Yuque"><a href="https://yuque.com/huijing" style="display:inline-block;vertical-align:middle">huijing</a></p>
          <p><img class="j-icon plain" data-src="img/codepen.png" alt="Codepen"><a href="http://codepen.io/huijing/" style="display:inline-block;vertical-align:middle">@huijing</a></p>
          <p style="text-align:right"><small>拉丁字体是由 <a href="https://www.motyfo.com/">Olivier Gourvat</a> 设计的 <a href="https://www.motyfo.com/fonts-library/magnetic-pro/">Magnetic Pro</a></small></p>
          <aside class="notes">谢谢大家。</aside>
        </section>
      </div>

      <footer style="position:absolute;width:calc(100% - 1em);bottom:0;font-size:40%;z-index:1;display:flex;justify-content:space-between;padding:0.5em"><span>https://huijing.github.io/slides/53-cssconfcn-2019</span><span style="text-align:right">@hj_chen | jing74737871</span></footer>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script src="lib/js/caniuse-embed.min.js"></script>
    <script async src="lib/js/ei.js"></script>

    <script>
    Reveal.initialize({
      dependencies: [
        { src: 'plugin/markdown/marked.js' },
        { src: 'plugin/markdown/markdown.js' },
        { src: 'plugin/notes/notes.js', async: true },
        { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
      ]
    });
    </script>
  </body>

</html>
